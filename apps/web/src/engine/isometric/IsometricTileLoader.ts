/**
 * IsometricTileLoader.ts - Loads precompiled isometric tile GLBs
 *
 * Loads GLB files generated by scripts/compile-tiles.ts.
 * Provides instancing for efficient rendering of many tiles.
 */

import {
  type AbstractMesh,
  type InstancedMesh,
  type Mesh,
  type Scene,
  SceneLoader,
  Vector3,
} from '@babylonjs/core';
import '@babylonjs/loaders/glTF';

import { TerrainType } from './IsometricTypes';

// ============================================================================
// TILE PATH MAPPING
// ============================================================================

const TILE_BASE_PATH = '/assets/tiles/isometric/';

/**
 * Maps TerrainType enum to compiled GLB filename.
 */
function terrainTypeToGLBPath(terrain: TerrainType): string {
  const mapping: Record<TerrainType, string> = {
    [TerrainType.Grass]: 'grass.glb',
    [TerrainType.GrassDry]: 'grass_dry.glb',
    [TerrainType.Sand]: 'sand.glb',
    [TerrainType.SandDunes]: 'sand_dunes.glb',
    [TerrainType.Dirt]: 'dirt.glb',
    [TerrainType.DirtPath]: 'dirt_path.glb',
    [TerrainType.Stone]: 'stone.glb',
    [TerrainType.StoneRough]: 'stone_rough.glb',
    [TerrainType.Water]: 'water.glb',
    [TerrainType.WaterShallow]: 'water_shallow.glb',
    [TerrainType.Mesa]: 'mesa.glb',
    [TerrainType.Badlands]: 'badlands.glb',
    [TerrainType.Clay]: 'clay.glb',
  };
  return TILE_BASE_PATH + mapping[terrain];
}

// ============================================================================
// TILE LOADER CLASS
// ============================================================================

export class IsometricTileLoader {
  private scene: Scene;
  private templateMeshes: Map<TerrainType, Mesh> = new Map();
  private loadingPromises: Map<TerrainType, Promise<Mesh>> = new Map();
  private instanceCounters: Map<TerrainType, number> = new Map();

  constructor(scene: Scene) {
    this.scene = scene;
  }

  /**
   * Initialize the loader - preload common tile types.
   */
  async init(): Promise<void> {
    const commonTypes = [
      TerrainType.Grass,
      TerrainType.Sand,
      TerrainType.Dirt,
      TerrainType.Stone,
    ];

    const promises = commonTypes.map((t) => this.loadTile(t));
    await Promise.all(promises);

    console.log('[IsometricTileLoader] Initialized with common tiles');
  }

  /**
   * Loads a tile GLB and caches the template mesh.
   */
  async loadTile(terrain: TerrainType): Promise<Mesh> {
    // Return cached template
    const cached = this.templateMeshes.get(terrain);
    if (cached) {
      return cached;
    }

    // Return in-flight promise if loading
    const loading = this.loadingPromises.get(terrain);
    if (loading) {
      return loading;
    }

    // Start loading
    const path = terrainTypeToGLBPath(terrain);
    const promise = this.loadGLB(terrain, path);
    this.loadingPromises.set(terrain, promise);

    try {
      const mesh = await promise;
      this.templateMeshes.set(terrain, mesh);
      this.loadingPromises.delete(terrain);
      return mesh;
    } catch (err) {
      this.loadingPromises.delete(terrain);
      throw err;
    }
  }

  /**
   * Loads a GLB file and returns the root mesh.
   */
  private async loadGLB(terrain: TerrainType, path: string): Promise<Mesh> {
    const result = await SceneLoader.ImportMeshAsync('', path, '', this.scene);

    if (result.meshes.length === 0) {
      throw new Error(`[IsometricTileLoader] No meshes in GLB: ${path}`);
    }

    // Find the actual geometry mesh (not the __root__)
    const mesh = result.meshes.find(
      (m) => m.name !== '__root__' && m.getTotalVertices() > 0
    ) as Mesh;

    if (!mesh) {
      throw new Error(`[IsometricTileLoader] No geometry mesh in GLB: ${path}`);
    }

    // Setup as template
    mesh.name = `template_${terrain}`;
    mesh.isVisible = false;
    mesh.setEnabled(false);

    // Enable instancing
    mesh.alwaysSelectAsActiveMesh = true;

    // Dispose __root__ if separate
    const root = result.meshes.find((m) => m.name === '__root__');
    if (root && root !== mesh) {
      mesh.parent = null;
      root.dispose();
    }

    console.log(`[IsometricTileLoader] Loaded: ${terrain} from ${path}`);
    return mesh;
  }

  /**
   * Checks if a tile type is loaded.
   */
  isLoaded(terrain: TerrainType): boolean {
    return this.templateMeshes.has(terrain);
  }

  /**
   * Creates an instance of a tile at the specified position.
   */
  async getInstance(
    terrain: TerrainType,
    position: Vector3,
    rotation: number = 0
  ): Promise<InstancedMesh> {
    // Ensure loaded
    if (!this.isLoaded(terrain)) {
      await this.loadTile(terrain);
    }

    const template = this.templateMeshes.get(terrain);
    if (!template) {
      throw new Error(`[IsometricTileLoader] Template not found: ${terrain}`);
    }

    // Create instance
    const count = this.instanceCounters.get(terrain) ?? 0;
    this.instanceCounters.set(terrain, count + 1);

    const instance = template.createInstance(`${terrain}_instance_${count}`);
    instance.position = position;
    instance.rotation.y = rotation;
    instance.receiveShadows = true;

    return instance;
  }

  /**
   * Creates a cloned mesh (for when you need unique material modifications).
   */
  async getClone(
    terrain: TerrainType,
    position: Vector3,
    rotation: number = 0
  ): Promise<Mesh> {
    if (!this.isLoaded(terrain)) {
      await this.loadTile(terrain);
    }

    const template = this.templateMeshes.get(terrain);
    if (!template) {
      throw new Error(`[IsometricTileLoader] Template not found: ${terrain}`);
    }

    const count = this.instanceCounters.get(terrain) ?? 0;
    this.instanceCounters.set(terrain, count + 1);

    const clone = template.clone(`${terrain}_clone_${count}`, null);
    if (!clone) {
      throw new Error(`[IsometricTileLoader] Failed to clone: ${terrain}`);
    }

    clone.isVisible = true;
    clone.setEnabled(true);
    clone.position = position;
    clone.rotation.y = rotation;
    clone.receiveShadows = true;

    return clone;
  }

  /**
   * Gets the template mesh for a terrain type (for direct access).
   */
  getTemplate(terrain: TerrainType): Mesh | undefined {
    return this.templateMeshes.get(terrain);
  }

  /**
   * Disposes all loaded tiles.
   */
  dispose(): void {
    for (const mesh of this.templateMeshes.values()) {
      mesh.dispose();
    }
    this.templateMeshes.clear();
    this.loadingPromises.clear();
    this.instanceCounters.clear();

    console.log('[IsometricTileLoader] Disposed');
  }
}

// ============================================================================
// SINGLETON INSTANCE
// ============================================================================

let loaderInstance: IsometricTileLoader | null = null;

/**
 * Gets the singleton tile loader for a scene.
 */
export function getIsometricTileLoader(scene: Scene): IsometricTileLoader {
  if (!loaderInstance || loaderInstance['scene'] !== scene) {
    loaderInstance = new IsometricTileLoader(scene);
  }
  return loaderInstance;
}
